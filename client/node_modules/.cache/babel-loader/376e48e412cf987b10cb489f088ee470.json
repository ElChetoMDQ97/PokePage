{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar MultiRef = /*#__PURE__*/function () {\n  function MultiRef() {\n    (0, _classCallCheck2[\"default\"])(this, MultiRef);\n    (0, _defineProperty2[\"default\"])(this, \"map\", new Map());\n    (0, _defineProperty2[\"default\"])(this, \"_refFns\", new Map());\n  }\n\n  (0, _createClass2[\"default\"])(MultiRef, [{\n    key: \"ref\",\n    value: function ref(key) {\n      var _this = this;\n\n      var refFn = this._refFns.get(key);\n\n      if (refFn) {\n        return refFn;\n      } else {\n        var _refFn = function _refFn(value) {\n          if (value == null) {\n            _this._refFns[\"delete\"](key);\n\n            _this.map[\"delete\"](key);\n          } else {\n            _this._refFns.set(key, _refFn);\n\n            _this.map.set(key, value);\n          }\n        }; // We don't put `refFn` into `this._refFns` yet, because if the current render\n        // is aborted, then it's possible than `refFn(null)` won't be called later\n        // and its cleanup will never happen. We shouldn't cause any side effects that\n        // need cleaning up later until `refFn` gets called with a non-null value.\n\n\n        return _refFn;\n      }\n    }\n  }]);\n  return MultiRef;\n}();\n\nexports[\"default\"] = MultiRef;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;IAIqBA,Q;;;kDACH,IAAIC,GAAJ;sDAEW,IAAIA,GAAJ;;;;;WAE3B,aAAIC,GAAJ,EAAsB;MAAA;;MACpB,IAAMC,KAAK,GAAG,KAAKC,OAAL,CAAaC,GAAb,CAAiBH,GAAjB,CAAd;;MACA,IAAIC,KAAJ,EAAW;QACT,OAAOA,KAAP;MADF,OAEO;QACL,IAAMA,MAAe,GAAG,SAAlBA,MAAkB,QAAS;UAC/B,IAAIG,KAAK,IAAI,IAAb,EAAmB;YACjBC,KAAI,CAACH,OAAL,WAAoBF,GAApB;;YACAK,KAAI,CAACC,GAAL,WAAgBN,GAAhB;UAFF,OAGO;YACLK,KAAI,CAACH,OAAL,CAAaK,GAAb,CAAiBP,GAAjB,EAAsBC,MAAtB;;YACAI,KAAI,CAACC,GAAL,CAASC,GAAT,CAAaP,GAAb,EAAkBI,KAAlB;UACD;QAPH,EADK,CAUL;QACA;QACA;QACA;;;QACA,OAAOH,MAAP;MACD;IACF","names":["MultiRef","Map","key","refFn","_refFns","get","value","_this","map","set"],"sources":["../src/index.js"],"sourcesContent":["/* @flow */\n\ntype RefFn<V> = (value: V|null) => mixed;\n\nexport default class MultiRef<K,V> {\n  map: Map<K,V> = new Map();\n\n  _refFns: Map<K,RefFn<V>> = new Map();\n\n  ref(key: K): RefFn<V> {\n    const refFn = this._refFns.get(key);\n    if (refFn) {\n      return refFn;\n    } else {\n      const refFn: RefFn<V> = value => {\n        if (value == null) {\n          this._refFns.delete(key);\n          this.map.delete(key);\n        } else {\n          this._refFns.set(key, refFn);\n          this.map.set(key, value);\n        }\n      };\n      // We don't put `refFn` into `this._refFns` yet, because if the current render\n      // is aborted, then it's possible than `refFn(null)` won't be called later\n      // and its cleanup will never happen. We shouldn't cause any side effects that\n      // need cleaning up later until `refFn` gets called with a non-null value.\n      return refFn;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}